// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_device

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func DeviceResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"additional_info": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{},
				CustomType: AdditionalInfoType{
					ObjectType: types.ObjectType{
						AttrTypes: AdditionalInfoValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"created_time": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Timestamp of the device creation, in milliseconds",
				MarkdownDescription: "Timestamp of the device creation, in milliseconds",
			},
			"customer_id": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"entity_type": schema.StringAttribute{
						Required:            true,
						Description:         "string",
						MarkdownDescription: "string",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"CUSTOMER",
							),
						},
					},
					"id": schema.StringAttribute{
						Required:            true,
						Description:         "ID of the entity, time-based UUID v1",
						MarkdownDescription: "ID of the entity, time-based UUID v1",
					},
				},
				CustomType: CustomerIdType{
					ObjectType: types.ObjectType{
						AttrTypes: CustomerIdValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"device_data": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"configuration": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{},
						CustomType: ConfigurationType{
							ObjectType: types.ObjectType{
								AttrTypes: ConfigurationValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
						Computed: true,
					},
					"transport_configuration": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{},
						CustomType: TransportConfigurationType{
							ObjectType: types.ObjectType{
								AttrTypes: TransportConfigurationValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
						Computed: true,
					},
				},
				CustomType: DeviceDataType{
					ObjectType: types.ObjectType{
						AttrTypes: DeviceDataValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"device_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "A string value representing the device id. For example, '784f394c-42b6-435a-983c-b7beff2784f9'",
				MarkdownDescription: "A string value representing the device id. For example, '784f394c-42b6-435a-983c-b7beff2784f9'",
			},
			"device_profile_id": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"entity_type": schema.StringAttribute{
						Required:            true,
						Description:         "string",
						MarkdownDescription: "string",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"DEVICE_PROFILE",
							),
						},
					},
					"id": schema.StringAttribute{
						Required:            true,
						Description:         "ID of the entity, time-based UUID v1",
						MarkdownDescription: "ID of the entity, time-based UUID v1",
					},
				},
				CustomType: DeviceProfileIdType{
					ObjectType: types.ObjectType{
						AttrTypes: DeviceProfileIdValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"firmware_id": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"entity_type": schema.StringAttribute{
						Required:            true,
						Description:         "string",
						MarkdownDescription: "string",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"OTA_PACKAGE",
							),
						},
					},
					"id": schema.StringAttribute{
						Required:            true,
						Description:         "ID of the entity, time-based UUID v1",
						MarkdownDescription: "ID of the entity, time-based UUID v1",
					},
				},
				CustomType: FirmwareIdType{
					ObjectType: types.ObjectType{
						AttrTypes: FirmwareIdValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"id": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"entity_type": schema.StringAttribute{
						Required:            true,
						Description:         "string",
						MarkdownDescription: "string",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"DEVICE",
							),
						},
					},
					"id": schema.StringAttribute{
						Required:            true,
						Description:         "ID of the entity, time-based UUID v1",
						MarkdownDescription: "ID of the entity, time-based UUID v1",
					},
				},
				CustomType: IdType{
					ObjectType: types.ObjectType{
						AttrTypes: IdValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"label": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Label that may be used in widgets",
				MarkdownDescription: "Label that may be used in widgets",
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "Unique Device Name in scope of Tenant",
				MarkdownDescription: "Unique Device Name in scope of Tenant",
			},
			"software_id": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"entity_type": schema.StringAttribute{
						Required:            true,
						Description:         "string",
						MarkdownDescription: "string",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"OTA_PACKAGE",
							),
						},
					},
					"id": schema.StringAttribute{
						Required:            true,
						Description:         "ID of the entity, time-based UUID v1",
						MarkdownDescription: "ID of the entity, time-based UUID v1",
					},
				},
				CustomType: SoftwareIdType{
					ObjectType: types.ObjectType{
						AttrTypes: SoftwareIdValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"tenant_id": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"entity_type": schema.StringAttribute{
						Required:            true,
						Description:         "string",
						MarkdownDescription: "string",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"TENANT",
							),
						},
					},
					"id": schema.StringAttribute{
						Required:            true,
						Description:         "ID of the entity, time-based UUID v1",
						MarkdownDescription: "ID of the entity, time-based UUID v1",
					},
				},
				CustomType: TenantIdType{
					ObjectType: types.ObjectType{
						AttrTypes: TenantIdValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Device Profile Name",
				MarkdownDescription: "Device Profile Name",
			},
		},
	}
}

type DeviceModel struct {
	AdditionalInfo  AdditionalInfoValue  `tfsdk:"additional_info"`
	CreatedTime     types.Int64          `tfsdk:"created_time"`
	CustomerId      CustomerIdValue      `tfsdk:"customer_id"`
	DeviceData      DeviceDataValue      `tfsdk:"device_data"`
	DeviceId        types.String         `tfsdk:"device_id"`
	DeviceProfileId DeviceProfileIdValue `tfsdk:"device_profile_id"`
	FirmwareId      FirmwareIdValue      `tfsdk:"firmware_id"`
	Id              IdValue              `tfsdk:"id"`
	Label           types.String         `tfsdk:"label"`
	Name            types.String         `tfsdk:"name"`
	SoftwareId      SoftwareIdValue      `tfsdk:"software_id"`
	TenantId        TenantIdValue        `tfsdk:"tenant_id"`
	Type            types.String         `tfsdk:"type"`
}

var _ basetypes.ObjectTypable = AdditionalInfoType{}

type AdditionalInfoType struct {
	basetypes.ObjectType
}

func (t AdditionalInfoType) Equal(o attr.Type) bool {
	other, ok := o.(AdditionalInfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AdditionalInfoType) String() string {
	return "AdditionalInfoType"
}

func (t AdditionalInfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return AdditionalInfoValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewAdditionalInfoValueNull() AdditionalInfoValue {
	return AdditionalInfoValue{
		state: attr.ValueStateNull,
	}
}

func NewAdditionalInfoValueUnknown() AdditionalInfoValue {
	return AdditionalInfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAdditionalInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AdditionalInfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AdditionalInfoValue Attribute Value",
				"While creating a AdditionalInfoValue value, a missing attribute value was detected. "+
					"A AdditionalInfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AdditionalInfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AdditionalInfoValue Attribute Type",
				"While creating a AdditionalInfoValue value, an invalid attribute value was detected. "+
					"A AdditionalInfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AdditionalInfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AdditionalInfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AdditionalInfoValue Attribute Value",
				"While creating a AdditionalInfoValue value, an extra attribute value was detected. "+
					"A AdditionalInfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AdditionalInfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAdditionalInfoValueUnknown(), diags
	}

	if diags.HasError() {
		return NewAdditionalInfoValueUnknown(), diags
	}

	return AdditionalInfoValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewAdditionalInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AdditionalInfoValue {
	object, diags := NewAdditionalInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAdditionalInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AdditionalInfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAdditionalInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAdditionalInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAdditionalInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAdditionalInfoValueMust(AdditionalInfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AdditionalInfoType) ValueType(ctx context.Context) attr.Value {
	return AdditionalInfoValue{}
}

var _ basetypes.ObjectValuable = AdditionalInfoValue{}

type AdditionalInfoValue struct {
	state attr.ValueState
}

func (v AdditionalInfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AdditionalInfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AdditionalInfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AdditionalInfoValue) String() string {
	return "AdditionalInfoValue"
}

func (v AdditionalInfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{},
		map[string]attr.Value{})

	return objVal, diags
}

func (v AdditionalInfoValue) Equal(o attr.Value) bool {
	other, ok := o.(AdditionalInfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v AdditionalInfoValue) Type(ctx context.Context) attr.Type {
	return AdditionalInfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AdditionalInfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}

var _ basetypes.ObjectTypable = CustomerIdType{}

type CustomerIdType struct {
	basetypes.ObjectType
}

func (t CustomerIdType) Equal(o attr.Type) bool {
	other, ok := o.(CustomerIdType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CustomerIdType) String() string {
	return "CustomerIdType"
}

func (t CustomerIdType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	entityTypeAttribute, ok := attributes["entity_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entity_type is missing from object`)

		return nil, diags
	}

	entityTypeVal, ok := entityTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entity_type expected to be basetypes.StringValue, was: %T`, entityTypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CustomerIdValue{
		EntityType: entityTypeVal,
		Id:         idVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewCustomerIdValueNull() CustomerIdValue {
	return CustomerIdValue{
		state: attr.ValueStateNull,
	}
}

func NewCustomerIdValueUnknown() CustomerIdValue {
	return CustomerIdValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCustomerIdValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CustomerIdValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CustomerIdValue Attribute Value",
				"While creating a CustomerIdValue value, a missing attribute value was detected. "+
					"A CustomerIdValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomerIdValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CustomerIdValue Attribute Type",
				"While creating a CustomerIdValue value, an invalid attribute value was detected. "+
					"A CustomerIdValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomerIdValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CustomerIdValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CustomerIdValue Attribute Value",
				"While creating a CustomerIdValue value, an extra attribute value was detected. "+
					"A CustomerIdValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CustomerIdValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCustomerIdValueUnknown(), diags
	}

	entityTypeAttribute, ok := attributes["entity_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entity_type is missing from object`)

		return NewCustomerIdValueUnknown(), diags
	}

	entityTypeVal, ok := entityTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entity_type expected to be basetypes.StringValue, was: %T`, entityTypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewCustomerIdValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return NewCustomerIdValueUnknown(), diags
	}

	return CustomerIdValue{
		EntityType: entityTypeVal,
		Id:         idVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewCustomerIdValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CustomerIdValue {
	object, diags := NewCustomerIdValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCustomerIdValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CustomerIdType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCustomerIdValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCustomerIdValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCustomerIdValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCustomerIdValueMust(CustomerIdValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CustomerIdType) ValueType(ctx context.Context) attr.Value {
	return CustomerIdValue{}
}

var _ basetypes.ObjectValuable = CustomerIdValue{}

type CustomerIdValue struct {
	EntityType basetypes.StringValue `tfsdk:"entity_type"`
	Id         basetypes.StringValue `tfsdk:"id"`
	state      attr.ValueState
}

func (v CustomerIdValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["entity_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.EntityType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["entity_type"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CustomerIdValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CustomerIdValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CustomerIdValue) String() string {
	return "CustomerIdValue"
}

func (v CustomerIdValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"entity_type": basetypes.StringType{},
			"id":          basetypes.StringType{},
		},
		map[string]attr.Value{
			"entity_type": v.EntityType,
			"id":          v.Id,
		})

	return objVal, diags
}

func (v CustomerIdValue) Equal(o attr.Value) bool {
	other, ok := o.(CustomerIdValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EntityType.Equal(other.EntityType) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	return true
}

func (v CustomerIdValue) Type(ctx context.Context) attr.Type {
	return CustomerIdType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CustomerIdValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"entity_type": basetypes.StringType{},
		"id":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DeviceDataType{}

type DeviceDataType struct {
	basetypes.ObjectType
}

func (t DeviceDataType) Equal(o attr.Type) bool {
	other, ok := o.(DeviceDataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviceDataType) String() string {
	return "DeviceDataType"
}

func (t DeviceDataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configurationAttribute, ok := attributes["configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configuration is missing from object`)

		return nil, diags
	}

	configurationVal, ok := configurationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configuration expected to be basetypes.ObjectValue, was: %T`, configurationAttribute))
	}

	transportConfigurationAttribute, ok := attributes["transport_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transport_configuration is missing from object`)

		return nil, diags
	}

	transportConfigurationVal, ok := transportConfigurationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transport_configuration expected to be basetypes.ObjectValue, was: %T`, transportConfigurationAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviceDataValue{
		Configuration:          configurationVal,
		TransportConfiguration: transportConfigurationVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewDeviceDataValueNull() DeviceDataValue {
	return DeviceDataValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviceDataValueUnknown() DeviceDataValue {
	return DeviceDataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviceDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviceDataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviceDataValue Attribute Value",
				"While creating a DeviceDataValue value, a missing attribute value was detected. "+
					"A DeviceDataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceDataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviceDataValue Attribute Type",
				"While creating a DeviceDataValue value, an invalid attribute value was detected. "+
					"A DeviceDataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceDataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviceDataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviceDataValue Attribute Value",
				"While creating a DeviceDataValue value, an extra attribute value was detected. "+
					"A DeviceDataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviceDataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviceDataValueUnknown(), diags
	}

	configurationAttribute, ok := attributes["configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configuration is missing from object`)

		return NewDeviceDataValueUnknown(), diags
	}

	configurationVal, ok := configurationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configuration expected to be basetypes.ObjectValue, was: %T`, configurationAttribute))
	}

	transportConfigurationAttribute, ok := attributes["transport_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transport_configuration is missing from object`)

		return NewDeviceDataValueUnknown(), diags
	}

	transportConfigurationVal, ok := transportConfigurationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transport_configuration expected to be basetypes.ObjectValue, was: %T`, transportConfigurationAttribute))
	}

	if diags.HasError() {
		return NewDeviceDataValueUnknown(), diags
	}

	return DeviceDataValue{
		Configuration:          configurationVal,
		TransportConfiguration: transportConfigurationVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewDeviceDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviceDataValue {
	object, diags := NewDeviceDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviceDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviceDataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviceDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviceDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviceDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviceDataValueMust(DeviceDataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviceDataType) ValueType(ctx context.Context) attr.Value {
	return DeviceDataValue{}
}

var _ basetypes.ObjectValuable = DeviceDataValue{}

type DeviceDataValue struct {
	Configuration          basetypes.ObjectValue `tfsdk:"configuration"`
	TransportConfiguration basetypes.ObjectValue `tfsdk:"transport_configuration"`
	state                  attr.ValueState
}

func (v DeviceDataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["configuration"] = basetypes.ObjectType{
		AttrTypes: ConfigurationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["transport_configuration"] = basetypes.ObjectType{
		AttrTypes: TransportConfigurationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Configuration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["configuration"] = val

		val, err = v.TransportConfiguration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["transport_configuration"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviceDataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviceDataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviceDataValue) String() string {
	return "DeviceDataValue"
}

func (v DeviceDataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var configuration basetypes.ObjectValue

	if v.Configuration.IsNull() {
		configuration = types.ObjectNull(
			ConfigurationValue{}.AttributeTypes(ctx),
		)
	}

	if v.Configuration.IsUnknown() {
		configuration = types.ObjectUnknown(
			ConfigurationValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Configuration.IsNull() && !v.Configuration.IsUnknown() {
		configuration = types.ObjectValueMust(
			ConfigurationValue{}.AttributeTypes(ctx),
			v.Configuration.Attributes(),
		)
	}

	var transportConfiguration basetypes.ObjectValue

	if v.TransportConfiguration.IsNull() {
		transportConfiguration = types.ObjectNull(
			TransportConfigurationValue{}.AttributeTypes(ctx),
		)
	}

	if v.TransportConfiguration.IsUnknown() {
		transportConfiguration = types.ObjectUnknown(
			TransportConfigurationValue{}.AttributeTypes(ctx),
		)
	}

	if !v.TransportConfiguration.IsNull() && !v.TransportConfiguration.IsUnknown() {
		transportConfiguration = types.ObjectValueMust(
			TransportConfigurationValue{}.AttributeTypes(ctx),
			v.TransportConfiguration.Attributes(),
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"configuration": basetypes.ObjectType{
				AttrTypes: ConfigurationValue{}.AttributeTypes(ctx),
			},
			"transport_configuration": basetypes.ObjectType{
				AttrTypes: TransportConfigurationValue{}.AttributeTypes(ctx),
			},
		},
		map[string]attr.Value{
			"configuration":           configuration,
			"transport_configuration": transportConfiguration,
		})

	return objVal, diags
}

func (v DeviceDataValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviceDataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Configuration.Equal(other.Configuration) {
		return false
	}

	if !v.TransportConfiguration.Equal(other.TransportConfiguration) {
		return false
	}

	return true
}

func (v DeviceDataValue) Type(ctx context.Context) attr.Type {
	return DeviceDataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviceDataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"configuration": basetypes.ObjectType{
			AttrTypes: ConfigurationValue{}.AttributeTypes(ctx),
		},
		"transport_configuration": basetypes.ObjectType{
			AttrTypes: TransportConfigurationValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ConfigurationType{}

type ConfigurationType struct {
	basetypes.ObjectType
}

func (t ConfigurationType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigurationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigurationType) String() string {
	return "ConfigurationType"
}

func (t ConfigurationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return ConfigurationValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigurationValueNull() ConfigurationValue {
	return ConfigurationValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigurationValueUnknown() ConfigurationValue {
	return ConfigurationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigurationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigurationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigurationValue Attribute Value",
				"While creating a ConfigurationValue value, a missing attribute value was detected. "+
					"A ConfigurationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigurationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigurationValue Attribute Type",
				"While creating a ConfigurationValue value, an invalid attribute value was detected. "+
					"A ConfigurationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigurationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigurationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigurationValue Attribute Value",
				"While creating a ConfigurationValue value, an extra attribute value was detected. "+
					"A ConfigurationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigurationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigurationValueUnknown(), diags
	}

	if diags.HasError() {
		return NewConfigurationValueUnknown(), diags
	}

	return ConfigurationValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigurationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigurationValue {
	object, diags := NewConfigurationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigurationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigurationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigurationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigurationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigurationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigurationValueMust(ConfigurationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigurationType) ValueType(ctx context.Context) attr.Value {
	return ConfigurationValue{}
}

var _ basetypes.ObjectValuable = ConfigurationValue{}

type ConfigurationValue struct {
	state attr.ValueState
}

func (v ConfigurationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigurationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigurationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigurationValue) String() string {
	return "ConfigurationValue"
}

func (v ConfigurationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{},
		map[string]attr.Value{})

	return objVal, diags
}

func (v ConfigurationValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigurationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v ConfigurationValue) Type(ctx context.Context) attr.Type {
	return ConfigurationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigurationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}

var _ basetypes.ObjectTypable = TransportConfigurationType{}

type TransportConfigurationType struct {
	basetypes.ObjectType
}

func (t TransportConfigurationType) Equal(o attr.Type) bool {
	other, ok := o.(TransportConfigurationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TransportConfigurationType) String() string {
	return "TransportConfigurationType"
}

func (t TransportConfigurationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return TransportConfigurationValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewTransportConfigurationValueNull() TransportConfigurationValue {
	return TransportConfigurationValue{
		state: attr.ValueStateNull,
	}
}

func NewTransportConfigurationValueUnknown() TransportConfigurationValue {
	return TransportConfigurationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTransportConfigurationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TransportConfigurationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TransportConfigurationValue Attribute Value",
				"While creating a TransportConfigurationValue value, a missing attribute value was detected. "+
					"A TransportConfigurationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TransportConfigurationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TransportConfigurationValue Attribute Type",
				"While creating a TransportConfigurationValue value, an invalid attribute value was detected. "+
					"A TransportConfigurationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TransportConfigurationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TransportConfigurationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TransportConfigurationValue Attribute Value",
				"While creating a TransportConfigurationValue value, an extra attribute value was detected. "+
					"A TransportConfigurationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TransportConfigurationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTransportConfigurationValueUnknown(), diags
	}

	if diags.HasError() {
		return NewTransportConfigurationValueUnknown(), diags
	}

	return TransportConfigurationValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewTransportConfigurationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TransportConfigurationValue {
	object, diags := NewTransportConfigurationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTransportConfigurationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TransportConfigurationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTransportConfigurationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTransportConfigurationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTransportConfigurationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTransportConfigurationValueMust(TransportConfigurationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TransportConfigurationType) ValueType(ctx context.Context) attr.Value {
	return TransportConfigurationValue{}
}

var _ basetypes.ObjectValuable = TransportConfigurationValue{}

type TransportConfigurationValue struct {
	state attr.ValueState
}

func (v TransportConfigurationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TransportConfigurationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TransportConfigurationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TransportConfigurationValue) String() string {
	return "TransportConfigurationValue"
}

func (v TransportConfigurationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{},
		map[string]attr.Value{})

	return objVal, diags
}

func (v TransportConfigurationValue) Equal(o attr.Value) bool {
	other, ok := o.(TransportConfigurationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v TransportConfigurationValue) Type(ctx context.Context) attr.Type {
	return TransportConfigurationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TransportConfigurationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}

var _ basetypes.ObjectTypable = DeviceProfileIdType{}

type DeviceProfileIdType struct {
	basetypes.ObjectType
}

func (t DeviceProfileIdType) Equal(o attr.Type) bool {
	other, ok := o.(DeviceProfileIdType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviceProfileIdType) String() string {
	return "DeviceProfileIdType"
}

func (t DeviceProfileIdType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	entityTypeAttribute, ok := attributes["entity_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entity_type is missing from object`)

		return nil, diags
	}

	entityTypeVal, ok := entityTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entity_type expected to be basetypes.StringValue, was: %T`, entityTypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviceProfileIdValue{
		EntityType: entityTypeVal,
		Id:         idVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewDeviceProfileIdValueNull() DeviceProfileIdValue {
	return DeviceProfileIdValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviceProfileIdValueUnknown() DeviceProfileIdValue {
	return DeviceProfileIdValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviceProfileIdValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviceProfileIdValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviceProfileIdValue Attribute Value",
				"While creating a DeviceProfileIdValue value, a missing attribute value was detected. "+
					"A DeviceProfileIdValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceProfileIdValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviceProfileIdValue Attribute Type",
				"While creating a DeviceProfileIdValue value, an invalid attribute value was detected. "+
					"A DeviceProfileIdValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceProfileIdValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviceProfileIdValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviceProfileIdValue Attribute Value",
				"While creating a DeviceProfileIdValue value, an extra attribute value was detected. "+
					"A DeviceProfileIdValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviceProfileIdValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviceProfileIdValueUnknown(), diags
	}

	entityTypeAttribute, ok := attributes["entity_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entity_type is missing from object`)

		return NewDeviceProfileIdValueUnknown(), diags
	}

	entityTypeVal, ok := entityTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entity_type expected to be basetypes.StringValue, was: %T`, entityTypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDeviceProfileIdValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return NewDeviceProfileIdValueUnknown(), diags
	}

	return DeviceProfileIdValue{
		EntityType: entityTypeVal,
		Id:         idVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewDeviceProfileIdValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviceProfileIdValue {
	object, diags := NewDeviceProfileIdValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviceProfileIdValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviceProfileIdType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviceProfileIdValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviceProfileIdValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviceProfileIdValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviceProfileIdValueMust(DeviceProfileIdValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviceProfileIdType) ValueType(ctx context.Context) attr.Value {
	return DeviceProfileIdValue{}
}

var _ basetypes.ObjectValuable = DeviceProfileIdValue{}

type DeviceProfileIdValue struct {
	EntityType basetypes.StringValue `tfsdk:"entity_type"`
	Id         basetypes.StringValue `tfsdk:"id"`
	state      attr.ValueState
}

func (v DeviceProfileIdValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["entity_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.EntityType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["entity_type"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviceProfileIdValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviceProfileIdValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviceProfileIdValue) String() string {
	return "DeviceProfileIdValue"
}

func (v DeviceProfileIdValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"entity_type": basetypes.StringType{},
			"id":          basetypes.StringType{},
		},
		map[string]attr.Value{
			"entity_type": v.EntityType,
			"id":          v.Id,
		})

	return objVal, diags
}

func (v DeviceProfileIdValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviceProfileIdValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EntityType.Equal(other.EntityType) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	return true
}

func (v DeviceProfileIdValue) Type(ctx context.Context) attr.Type {
	return DeviceProfileIdType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviceProfileIdValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"entity_type": basetypes.StringType{},
		"id":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FirmwareIdType{}

type FirmwareIdType struct {
	basetypes.ObjectType
}

func (t FirmwareIdType) Equal(o attr.Type) bool {
	other, ok := o.(FirmwareIdType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FirmwareIdType) String() string {
	return "FirmwareIdType"
}

func (t FirmwareIdType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	entityTypeAttribute, ok := attributes["entity_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entity_type is missing from object`)

		return nil, diags
	}

	entityTypeVal, ok := entityTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entity_type expected to be basetypes.StringValue, was: %T`, entityTypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FirmwareIdValue{
		EntityType: entityTypeVal,
		Id:         idVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewFirmwareIdValueNull() FirmwareIdValue {
	return FirmwareIdValue{
		state: attr.ValueStateNull,
	}
}

func NewFirmwareIdValueUnknown() FirmwareIdValue {
	return FirmwareIdValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFirmwareIdValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FirmwareIdValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FirmwareIdValue Attribute Value",
				"While creating a FirmwareIdValue value, a missing attribute value was detected. "+
					"A FirmwareIdValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FirmwareIdValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FirmwareIdValue Attribute Type",
				"While creating a FirmwareIdValue value, an invalid attribute value was detected. "+
					"A FirmwareIdValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FirmwareIdValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FirmwareIdValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FirmwareIdValue Attribute Value",
				"While creating a FirmwareIdValue value, an extra attribute value was detected. "+
					"A FirmwareIdValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FirmwareIdValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFirmwareIdValueUnknown(), diags
	}

	entityTypeAttribute, ok := attributes["entity_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entity_type is missing from object`)

		return NewFirmwareIdValueUnknown(), diags
	}

	entityTypeVal, ok := entityTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entity_type expected to be basetypes.StringValue, was: %T`, entityTypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewFirmwareIdValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return NewFirmwareIdValueUnknown(), diags
	}

	return FirmwareIdValue{
		EntityType: entityTypeVal,
		Id:         idVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewFirmwareIdValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FirmwareIdValue {
	object, diags := NewFirmwareIdValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFirmwareIdValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FirmwareIdType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFirmwareIdValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFirmwareIdValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFirmwareIdValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFirmwareIdValueMust(FirmwareIdValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FirmwareIdType) ValueType(ctx context.Context) attr.Value {
	return FirmwareIdValue{}
}

var _ basetypes.ObjectValuable = FirmwareIdValue{}

type FirmwareIdValue struct {
	EntityType basetypes.StringValue `tfsdk:"entity_type"`
	Id         basetypes.StringValue `tfsdk:"id"`
	state      attr.ValueState
}

func (v FirmwareIdValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["entity_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.EntityType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["entity_type"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FirmwareIdValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FirmwareIdValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FirmwareIdValue) String() string {
	return "FirmwareIdValue"
}

func (v FirmwareIdValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"entity_type": basetypes.StringType{},
			"id":          basetypes.StringType{},
		},
		map[string]attr.Value{
			"entity_type": v.EntityType,
			"id":          v.Id,
		})

	return objVal, diags
}

func (v FirmwareIdValue) Equal(o attr.Value) bool {
	other, ok := o.(FirmwareIdValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EntityType.Equal(other.EntityType) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	return true
}

func (v FirmwareIdValue) Type(ctx context.Context) attr.Type {
	return FirmwareIdType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FirmwareIdValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"entity_type": basetypes.StringType{},
		"id":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IdType{}

type IdType struct {
	basetypes.ObjectType
}

func (t IdType) Equal(o attr.Type) bool {
	other, ok := o.(IdType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IdType) String() string {
	return "IdType"
}

func (t IdType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	entityTypeAttribute, ok := attributes["entity_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entity_type is missing from object`)

		return nil, diags
	}

	entityTypeVal, ok := entityTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entity_type expected to be basetypes.StringValue, was: %T`, entityTypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IdValue{
		EntityType: entityTypeVal,
		Id:         idVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIdValueNull() IdValue {
	return IdValue{
		state: attr.ValueStateNull,
	}
}

func NewIdValueUnknown() IdValue {
	return IdValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIdValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IdValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IdValue Attribute Value",
				"While creating a IdValue value, a missing attribute value was detected. "+
					"A IdValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IdValue Attribute Type",
				"While creating a IdValue value, an invalid attribute value was detected. "+
					"A IdValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IdValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IdValue Attribute Value",
				"While creating a IdValue value, an extra attribute value was detected. "+
					"A IdValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IdValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIdValueUnknown(), diags
	}

	entityTypeAttribute, ok := attributes["entity_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entity_type is missing from object`)

		return NewIdValueUnknown(), diags
	}

	entityTypeVal, ok := entityTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entity_type expected to be basetypes.StringValue, was: %T`, entityTypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewIdValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return NewIdValueUnknown(), diags
	}

	return IdValue{
		EntityType: entityTypeVal,
		Id:         idVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIdValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IdValue {
	object, diags := NewIdValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIdValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IdType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIdValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIdValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIdValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIdValueMust(IdValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IdType) ValueType(ctx context.Context) attr.Value {
	return IdValue{}
}

var _ basetypes.ObjectValuable = IdValue{}

type IdValue struct {
	EntityType basetypes.StringValue `tfsdk:"entity_type"`
	Id         basetypes.StringValue `tfsdk:"id"`
	state      attr.ValueState
}

func (v IdValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["entity_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.EntityType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["entity_type"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IdValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IdValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IdValue) String() string {
	return "IdValue"
}

func (v IdValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"entity_type": basetypes.StringType{},
			"id":          basetypes.StringType{},
		},
		map[string]attr.Value{
			"entity_type": v.EntityType,
			"id":          v.Id,
		})

	return objVal, diags
}

func (v IdValue) Equal(o attr.Value) bool {
	other, ok := o.(IdValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EntityType.Equal(other.EntityType) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	return true
}

func (v IdValue) Type(ctx context.Context) attr.Type {
	return IdType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IdValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"entity_type": basetypes.StringType{},
		"id":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SoftwareIdType{}

type SoftwareIdType struct {
	basetypes.ObjectType
}

func (t SoftwareIdType) Equal(o attr.Type) bool {
	other, ok := o.(SoftwareIdType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SoftwareIdType) String() string {
	return "SoftwareIdType"
}

func (t SoftwareIdType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	entityTypeAttribute, ok := attributes["entity_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entity_type is missing from object`)

		return nil, diags
	}

	entityTypeVal, ok := entityTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entity_type expected to be basetypes.StringValue, was: %T`, entityTypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SoftwareIdValue{
		EntityType: entityTypeVal,
		Id:         idVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewSoftwareIdValueNull() SoftwareIdValue {
	return SoftwareIdValue{
		state: attr.ValueStateNull,
	}
}

func NewSoftwareIdValueUnknown() SoftwareIdValue {
	return SoftwareIdValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSoftwareIdValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SoftwareIdValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SoftwareIdValue Attribute Value",
				"While creating a SoftwareIdValue value, a missing attribute value was detected. "+
					"A SoftwareIdValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SoftwareIdValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SoftwareIdValue Attribute Type",
				"While creating a SoftwareIdValue value, an invalid attribute value was detected. "+
					"A SoftwareIdValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SoftwareIdValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SoftwareIdValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SoftwareIdValue Attribute Value",
				"While creating a SoftwareIdValue value, an extra attribute value was detected. "+
					"A SoftwareIdValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SoftwareIdValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSoftwareIdValueUnknown(), diags
	}

	entityTypeAttribute, ok := attributes["entity_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entity_type is missing from object`)

		return NewSoftwareIdValueUnknown(), diags
	}

	entityTypeVal, ok := entityTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entity_type expected to be basetypes.StringValue, was: %T`, entityTypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewSoftwareIdValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return NewSoftwareIdValueUnknown(), diags
	}

	return SoftwareIdValue{
		EntityType: entityTypeVal,
		Id:         idVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewSoftwareIdValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SoftwareIdValue {
	object, diags := NewSoftwareIdValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSoftwareIdValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SoftwareIdType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSoftwareIdValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSoftwareIdValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSoftwareIdValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSoftwareIdValueMust(SoftwareIdValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SoftwareIdType) ValueType(ctx context.Context) attr.Value {
	return SoftwareIdValue{}
}

var _ basetypes.ObjectValuable = SoftwareIdValue{}

type SoftwareIdValue struct {
	EntityType basetypes.StringValue `tfsdk:"entity_type"`
	Id         basetypes.StringValue `tfsdk:"id"`
	state      attr.ValueState
}

func (v SoftwareIdValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["entity_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.EntityType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["entity_type"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SoftwareIdValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SoftwareIdValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SoftwareIdValue) String() string {
	return "SoftwareIdValue"
}

func (v SoftwareIdValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"entity_type": basetypes.StringType{},
			"id":          basetypes.StringType{},
		},
		map[string]attr.Value{
			"entity_type": v.EntityType,
			"id":          v.Id,
		})

	return objVal, diags
}

func (v SoftwareIdValue) Equal(o attr.Value) bool {
	other, ok := o.(SoftwareIdValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EntityType.Equal(other.EntityType) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	return true
}

func (v SoftwareIdValue) Type(ctx context.Context) attr.Type {
	return SoftwareIdType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SoftwareIdValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"entity_type": basetypes.StringType{},
		"id":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TenantIdType{}

type TenantIdType struct {
	basetypes.ObjectType
}

func (t TenantIdType) Equal(o attr.Type) bool {
	other, ok := o.(TenantIdType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TenantIdType) String() string {
	return "TenantIdType"
}

func (t TenantIdType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	entityTypeAttribute, ok := attributes["entity_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entity_type is missing from object`)

		return nil, diags
	}

	entityTypeVal, ok := entityTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entity_type expected to be basetypes.StringValue, was: %T`, entityTypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TenantIdValue{
		EntityType: entityTypeVal,
		Id:         idVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewTenantIdValueNull() TenantIdValue {
	return TenantIdValue{
		state: attr.ValueStateNull,
	}
}

func NewTenantIdValueUnknown() TenantIdValue {
	return TenantIdValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTenantIdValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TenantIdValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TenantIdValue Attribute Value",
				"While creating a TenantIdValue value, a missing attribute value was detected. "+
					"A TenantIdValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TenantIdValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TenantIdValue Attribute Type",
				"While creating a TenantIdValue value, an invalid attribute value was detected. "+
					"A TenantIdValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TenantIdValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TenantIdValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TenantIdValue Attribute Value",
				"While creating a TenantIdValue value, an extra attribute value was detected. "+
					"A TenantIdValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TenantIdValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTenantIdValueUnknown(), diags
	}

	entityTypeAttribute, ok := attributes["entity_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entity_type is missing from object`)

		return NewTenantIdValueUnknown(), diags
	}

	entityTypeVal, ok := entityTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entity_type expected to be basetypes.StringValue, was: %T`, entityTypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewTenantIdValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return NewTenantIdValueUnknown(), diags
	}

	return TenantIdValue{
		EntityType: entityTypeVal,
		Id:         idVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewTenantIdValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TenantIdValue {
	object, diags := NewTenantIdValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTenantIdValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TenantIdType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTenantIdValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTenantIdValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTenantIdValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTenantIdValueMust(TenantIdValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TenantIdType) ValueType(ctx context.Context) attr.Value {
	return TenantIdValue{}
}

var _ basetypes.ObjectValuable = TenantIdValue{}

type TenantIdValue struct {
	EntityType basetypes.StringValue `tfsdk:"entity_type"`
	Id         basetypes.StringValue `tfsdk:"id"`
	state      attr.ValueState
}

func (v TenantIdValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["entity_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.EntityType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["entity_type"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TenantIdValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TenantIdValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TenantIdValue) String() string {
	return "TenantIdValue"
}

func (v TenantIdValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"entity_type": basetypes.StringType{},
			"id":          basetypes.StringType{},
		},
		map[string]attr.Value{
			"entity_type": v.EntityType,
			"id":          v.Id,
		})

	return objVal, diags
}

func (v TenantIdValue) Equal(o attr.Value) bool {
	other, ok := o.(TenantIdValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EntityType.Equal(other.EntityType) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	return true
}

func (v TenantIdValue) Type(ctx context.Context) attr.Type {
	return TenantIdType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TenantIdValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"entity_type": basetypes.StringType{},
		"id":          basetypes.StringType{},
	}
}
